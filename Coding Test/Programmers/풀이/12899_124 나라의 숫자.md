[1. 문제](#1-문제)  
[2. 풀이](#2-풀이)  
[3. 결과](#3-결과)  
[4. 참고](#4-참고)  

# 1. 문제

## 124 나라의 숫자

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/12899)

### 문제 설명

124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.

1. 124 나라에는 자연수만 존재합니다.
2. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.

예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.

|10진법|124 나라|
|-|-|
|1|1|
|2|2|
|3|4|
|4|11|
|5|12|
|6|14|
|7|21|
|8|22|
|9|24|
|10|41|

자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.

### 제한 사항

- n은 500,000,000이하의 자연수 입니다.

### 입출력 예

|n|result|
|-|-|
|1|1|
|2|2|
|3|4|
|4|11|

### 분류

- 

<br><br>

# 2. 풀이

> 10진법을 3진법으로 변환하는데, 나머지가 0일 때만 계산이 달라진다.
> 

10진법, 3진법, 124 나라 간의 변환이다.

|10진법|3진법|124나라|
|-|-|-|
|1|1|1|
|2|2|2|
|3|10|4|
|4|11|11|
|5|12|12|
|6|20|14|
|7|21|21|
|8|22|22|
|9|100|24|
|10|101|41|

위 표에서 알 수 있듯이, 나머지가 0일 때를 제외하곤 3진법과 동일하게 변경된다.

나머지가 0으로 나누어질 때, 몫을 -1 하고 나머지는 4가 되면 제대로 값이 나온다.

1. 우선 10진법을 3진법으로 변환하는 것을 구현한다.
    
    나머지는 먼저 나온 나머지가 나중에 출력 되어야 하므로 배열에 저장해두고 `reverse()` 메서드를 사용하여 뒤에서부터 출력해주었다.
    
    계산이 끝나고 n이 0이 아닐 때는 출력 되도록 배열에 추가하였다.
    
    ```jsx
    function solution(n) {
      let value = 0;
      let reminder = 0;
      let answer = [];
    
      while(n > 1) {
        value = Math.floor(n / 3);
        reminder = n % 3;
    
        answer.push(reminder);
    
        n = Math.floor(n / 3);
      }
    
      if(n > 0) answer.push(n);
    
      return answer.reverse().join("");
    }
    ```
    
2. 여기서 이제 n을 3으로 나누었을 때, 나머지가 0인 경우만 처리해주면 된다.
    
    ```jsx
    function solution(n) {
      let value = 0;
      let reminder = 0;
      let answer = [];
    
      while(n > 1) {
        value = Math.floor(n / 3);
        reminder = n % 3;
    
        **if(reminder === 0) {
          n -= 1;
          reminder = 4;
        }**
    
        answer.push(reminder);
    
        n = Math.floor(n / 3);
      }
    
      if(n > 0) answer.push(n);
    
      return answer.reverse().join("");
    }
    ```
    

<br>

### 제출

```jsx
function solution(n) {
  let answer = [];
  let value = 0;
  let reminder = 0;

  while(n > 1) {
    value = Math.floor(n / 3);
    reminder = n % 3;

    if(reminder === 0) {
      n -= 1;
      reminder = 4;
    }

    answer.push(reminder);

    n = Math.floor(n / 3);
  }

  if(n > 0) answer.push(n);

  return answer.reverse().join("");
}
```

### 다른 사람의 풀이 및 해석

```jsx
function change124(n) {
  return n === 0 ? '' : change124(parseInt((n - 1) / 3)) + [1, 2, 4][(n - 1) % 3];
}
```

재귀를 사용하여 구현하였다.

나는 n이 0보다 클 때 출력을 해주었는데, 여기선 삼항 연산자를 사용하여 0일 때 출력을 안 하는 것으로 하였다.

그리고 n을 3으로 나눌 때, (n - 1)을 해주는 것은 n을 나눈 "몫"은 -1을 해도 같은 값이 나오기 때문이다.

예를 들어 n = 13일 경우, `13 / 3 ⇒ 4` == `12 / 3 ⇒ 4` == `14 / 3 ⇒ 4` 동일하다.

마지막으로 몫 뒤에 나머지 값들을 붙여준다.

나머지 값은 [1, 2, 4] 배열에서 (n - 1) % 3의 인덱스에 있는 숫자가 나오게 된다. 여기서 -1을 해주는 이유는 인덱스가 0부터 시작하기 때문이다.

- n = 10인 경우 아래와 같다.  
  몫 : 10 ⇒ (10 - 1) / 3 ⇒ 3   
    (재귀) 3 ⇒ (3 - 1) / 3 ⇒ 0 ⇒ ''  
  나머지 : 10 ⇒ (10 - 1) % 3 ⇒ 0 ⇒ ''  
    (재귀) 3 ⇒ (3 - 1) % 3 ⇒ 2 ⇒ 4  

<br><br>

# 3. 채점 결과

```jsx
정확성  테스트
테스트 1 〉	통과 (0.05ms, 30.3MB)
테스트 2 〉	통과 (0.05ms, 30.2MB)
테스트 3 〉	통과 (0.06ms, 30.1MB)
테스트 4 〉	통과 (0.07ms, 30.1MB)
테스트 5 〉	통과 (0.06ms, 30.2MB)
테스트 6 〉	통과 (0.06ms, 30.2MB)
테스트 7 〉	통과 (0.08ms, 30.2MB)
테스트 8 〉	통과 (0.05ms, 30.3MB)
테스트 9 〉	통과 (0.06ms, 29.8MB)
테스트 10 〉	통과 (0.08ms, 30.2MB)
테스트 11 〉	통과 (0.14ms, 30.2MB)
테스트 12 〉	통과 (0.06ms, 29.9MB)
테스트 13 〉	통과 (0.06ms, 30.2MB)
테스트 14 〉	통과 (0.10ms, 30.1MB)

효율성  테스트
테스트 1 〉	통과 (0.08ms, 30.1MB)
테스트 2 〉	통과 (0.08ms, 30.2MB)
테스트 3 〉	통과 (0.06ms, 30.1MB)
테스트 4 〉	통과 (0.09ms, 30.2MB)
테스트 5 〉	통과 (0.09ms, 29.9MB)
테스트 6 〉	통과 (0.09ms, 30.1MB)
```

- **정확성 :** 70.0
- **효율성 :** 30.0
- **합계 :** 100.0 / 100.0

<br><br>

# 4. 참고
